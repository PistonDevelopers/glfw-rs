#[link(name = "glfw",
	   vers = "0.1",
       uuid = "6199FAD3-6D03-4E29-87E7-7DC1B1B65C2C",
	   author = "Brendan Zabarauskas",
	   url = "https://github.com/bjz/glfw3-rs")];

#[comment = "Bindings and wrapper functions for glfw3."];
#[crate_type = "lib"];

extern mod std;
use core::libc::*;
use core::ptr::to_unsafe_ptr;
use core::cast::transmute;

use task::local_data:: {
    local_data_get,
    local_data_set
};


// Include OS X Frameworks
#[nolink]
#[cfg(target_os = "macos")]
#[link_args="-framework Cocoa -framework OpenGL -framework IOKit -framework CoreFoundation"]
extern mod osx_frameworks {}

// GLFW Linking

#[link_name = "glfw"]
#[cfg(target_os = "macos")]
extern mod linkhack {}

#[link_name = "glfw"]
#[cfg(target_os = "linux")]
extern mod linkhack {}

// TODO: Fix GLFW linking on windows
// #[link_name = "???"]
// #[cfg(target_os = "windows")]
// extern mod linkhack{}

/*************************************************************************
 * GLFW version
 *************************************************************************/

pub const VERSION_MAJOR        : c_int = 3;
pub const VERSION_MINOR        : c_int = 0;
pub const VERSION_REVISION     : c_int = 0;

/*************************************************************************
 * Input handling definitions
 *************************************************************************/

/* Key and button state/action definitions */
pub const RELEASE              : c_int = 0;
pub const PRESS                : c_int = 1;
pub const REPEAT               : c_int = 2;

/* Printable keys */
pub const KEY_SPACE            : c_int = 32;
pub const KEY_APOSTROPHE       : c_int = 39;  /* ' */
pub const KEY_COMMA            : c_int = 44;  /* , */
pub const KEY_MINUS            : c_int = 45;  /* - */
pub const KEY_PERIOD           : c_int = 46;  /* . */
pub const KEY_SLASH            : c_int = 47;  /* / */
pub const KEY_0                : c_int = 48;
pub const KEY_1                : c_int = 49;
pub const KEY_2                : c_int = 50;
pub const KEY_3                : c_int = 51;
pub const KEY_4                : c_int = 52;
pub const KEY_5                : c_int = 53;
pub const KEY_6                : c_int = 54;
pub const KEY_7                : c_int = 55;
pub const KEY_8                : c_int = 56;
pub const KEY_9                : c_int = 57;
pub const KEY_SEMICOLON        : c_int = 59;  /* ; */
pub const KEY_EQUAL            : c_int = 61;  /* = */
pub const KEY_A                : c_int = 65;
pub const KEY_B                : c_int = 66;
pub const KEY_C                : c_int = 67;
pub const KEY_D                : c_int = 68;
pub const KEY_E                : c_int = 69;
pub const KEY_F                : c_int = 70;
pub const KEY_G                : c_int = 71;
pub const KEY_H                : c_int = 72;
pub const KEY_I                : c_int = 73;
pub const KEY_J                : c_int = 74;
pub const KEY_K                : c_int = 75;
pub const KEY_L                : c_int = 76;
pub const KEY_M                : c_int = 77;
pub const KEY_N                : c_int = 78;
pub const KEY_O                : c_int = 79;
pub const KEY_P                : c_int = 80;
pub const KEY_Q                : c_int = 81;
pub const KEY_R                : c_int = 82;
pub const KEY_S                : c_int = 83;
pub const KEY_T                : c_int = 84;
pub const KEY_U                : c_int = 85;
pub const KEY_V                : c_int = 86;
pub const KEY_W                : c_int = 87;
pub const KEY_X                : c_int = 88;
pub const KEY_Y                : c_int = 89;
pub const KEY_Z                : c_int = 90;
pub const KEY_LEFT_BRACKET     : c_int = 91;  /* [ */
pub const KEY_BACKSLASH        : c_int = 92;  /* \ */
pub const KEY_RIGHT_BRACKET    : c_int = 93;  /* ] */
pub const KEY_GRAVE_ACCENT     : c_int = 96;  /* ` */
pub const KEY_WORLD_1          : c_int = 161; /* non-US #1 */
pub const KEY_WORLD_2          : c_int = 162; /* non-US #2 */

/* Function keys */
pub const KEY_ESCAPE           : c_int = 256;
pub const KEY_ENTER            : c_int = 257;
pub const KEY_TAB              : c_int = 258;
pub const KEY_BACKSPACE        : c_int = 259;
pub const KEY_INSERT           : c_int = 260;
pub const KEY_DELETE           : c_int = 261;
pub const KEY_RIGHT            : c_int = 262;
pub const KEY_LEFT             : c_int = 263;
pub const KEY_DOWN             : c_int = 264;
pub const KEY_UP               : c_int = 265;
pub const KEY_PAGE_UP          : c_int = 266;
pub const KEY_PAGE_DOWN        : c_int = 267;
pub const KEY_HOME             : c_int = 268;
pub const KEY_END              : c_int = 269;
pub const KEY_CAPS_LOCK        : c_int = 280;
pub const KEY_SCROLL_LOCK      : c_int = 281;
pub const KEY_NUM_LOCK         : c_int = 282;
pub const KEY_PRINT_SCREEN     : c_int = 283;
pub const KEY_PAUSE            : c_int = 284;
pub const KEY_F1               : c_int = 290;
pub const KEY_F2               : c_int = 291;
pub const KEY_F3               : c_int = 292;
pub const KEY_F4               : c_int = 293;
pub const KEY_F5               : c_int = 294;
pub const KEY_F6               : c_int = 295;
pub const KEY_F7               : c_int = 296;
pub const KEY_F8               : c_int = 297;
pub const KEY_F9               : c_int = 298;
pub const KEY_F10              : c_int = 299;
pub const KEY_F11              : c_int = 300;
pub const KEY_F12              : c_int = 301;
pub const KEY_F13              : c_int = 302;
pub const KEY_F14              : c_int = 303;
pub const KEY_F15              : c_int = 304;
pub const KEY_F16              : c_int = 305;
pub const KEY_F17              : c_int = 306;
pub const KEY_F18              : c_int = 307;
pub const KEY_F19              : c_int = 308;
pub const KEY_F20              : c_int = 309;
pub const KEY_F21              : c_int = 310;
pub const KEY_F22              : c_int = 311;
pub const KEY_F23              : c_int = 312;
pub const KEY_F24              : c_int = 313;
pub const KEY_F25              : c_int = 314;
pub const KEY_KP_0             : c_int = 320;
pub const KEY_KP_1             : c_int = 321;
pub const KEY_KP_2             : c_int = 322;
pub const KEY_KP_3             : c_int = 323;
pub const KEY_KP_4             : c_int = 324;
pub const KEY_KP_5             : c_int = 325;
pub const KEY_KP_6             : c_int = 326;
pub const KEY_KP_7             : c_int = 327;
pub const KEY_KP_8             : c_int = 328;
pub const KEY_KP_9             : c_int = 329;
pub const KEY_KP_DECIMAL       : c_int = 330;
pub const KEY_KP_DIVIDE        : c_int = 331;
pub const KEY_KP_MULTIPLY      : c_int = 332;
pub const KEY_KP_SUBTRACT      : c_int = 333;
pub const KEY_KP_ADD           : c_int = 334;
pub const KEY_KP_ENTER         : c_int = 335;
pub const KEY_KP_EQUAL         : c_int = 336;
pub const KEY_LEFT_SHIFT       : c_int = 340;
pub const KEY_LEFT_CONTROL     : c_int = 341;
pub const KEY_LEFT_ALT         : c_int = 342;
pub const KEY_LEFT_SUPER       : c_int = 343;
pub const KEY_RIGHT_SHIFT      : c_int = 344;
pub const KEY_RIGHT_CONTROL    : c_int = 345;
pub const KEY_RIGHT_ALT        : c_int = 346;
pub const KEY_RIGHT_SUPER      : c_int = 347;
pub const KEY_MENU             : c_int = 348;
pub const KEY_LAST             : c_int = KEY_MENU;

/* GLFW 2.x key name aliases (deprecated) */
pub const KEY_ESC              : c_int = KEY_ESCAPE;
pub const KEY_DEL              : c_int = KEY_DELETE;
pub const KEY_PAGEUP           : c_int = KEY_PAGE_UP;
pub const KEY_PAGEDOWN         : c_int = KEY_PAGE_DOWN;
pub const KEY_KP_NUM_LOCK      : c_int = KEY_NUM_LOCK;
pub const KEY_LCTRL            : c_int = KEY_LEFT_CONTROL;
pub const KEY_LSHIFT           : c_int = KEY_LEFT_SHIFT;
pub const KEY_LALT             : c_int = KEY_LEFT_ALT;
pub const KEY_LSUPER           : c_int = KEY_LEFT_SUPER;
pub const KEY_RCTRL            : c_int = KEY_RIGHT_CONTROL;
pub const KEY_RSHIFT           : c_int = KEY_RIGHT_SHIFT;
pub const KEY_RALT             : c_int = KEY_RIGHT_ALT;
pub const KEY_RSUPER           : c_int = KEY_RIGHT_SUPER;

/* Mouse buttons */
pub const MOUSE_BUTTON_1       : c_int = 0;
pub const MOUSE_BUTTON_2       : c_int = 1;
pub const MOUSE_BUTTON_3       : c_int = 2;
pub const MOUSE_BUTTON_4       : c_int = 3;
pub const MOUSE_BUTTON_5       : c_int = 4;
pub const MOUSE_BUTTON_6       : c_int = 5;
pub const MOUSE_BUTTON_7       : c_int = 6;
pub const MOUSE_BUTTON_8       : c_int = 7;
pub const MOUSE_BUTTON_LEFT    : c_int = MOUSE_BUTTON_1;
pub const MOUSE_BUTTON_RIGHT   : c_int = MOUSE_BUTTON_2;
pub const MOUSE_BUTTON_MIDDLE  : c_int = MOUSE_BUTTON_3;
pub const MOUSE_BUTTON_LAST    : c_int = MOUSE_BUTTON_8;

/* Joysticks */
pub const JOYSTICK_1           : c_int = 0;
pub const JOYSTICK_2           : c_int = 1;
pub const JOYSTICK_3           : c_int = 2;
pub const JOYSTICK_4           : c_int = 3;
pub const JOYSTICK_5           : c_int = 4;
pub const JOYSTICK_6           : c_int = 5;
pub const JOYSTICK_7           : c_int = 6;
pub const JOYSTICK_8           : c_int = 7;
pub const JOYSTICK_9           : c_int = 8;
pub const JOYSTICK_10          : c_int = 9;
pub const JOYSTICK_11          : c_int = 10;
pub const JOYSTICK_12          : c_int = 11;
pub const JOYSTICK_13          : c_int = 12;
pub const JOYSTICK_14          : c_int = 13;
pub const JOYSTICK_15          : c_int = 14;
pub const JOYSTICK_16          : c_int = 15;
pub const JOYSTICK_LAST        : c_int = JOYSTICK_16;

pub struct Joystick { id : c_int }

pub const Joysticks : [Joystick * 16] = [
    Joystick { id: JOYSTICK_1  },
    Joystick { id: JOYSTICK_2  },
    Joystick { id: JOYSTICK_3  },
    Joystick { id: JOYSTICK_4  },
    Joystick { id: JOYSTICK_5  },
    Joystick { id: JOYSTICK_6  },
    Joystick { id: JOYSTICK_7  },
    Joystick { id: JOYSTICK_8  },
    Joystick { id: JOYSTICK_9  },
    Joystick { id: JOYSTICK_10 },
    Joystick { id: JOYSTICK_11 },
    Joystick { id: JOYSTICK_12 },
    Joystick { id: JOYSTICK_13 },
    Joystick { id: JOYSTICK_14 },
    Joystick { id: JOYSTICK_15 },
    Joystick { id: JOYSTICK_16 },
];

/*************************************************************************
 * Other definitions
 *************************************************************************/

/* Not actually defined in GLFW, but very useful */
pub const FALSE                        : c_int = 0;
pub const TRUE                         : c_int = 1;

/* glfwGetWindowParam tokens */
pub const FOCUSED                      : c_int = 0x00020001;
pub const ICONIFIED                    : c_int = 0x00020002;
pub const SHOULD_CLOSE                 : c_int = 0x00020003;
pub const CONTEXT_REVISION             : c_int = 0x00020004;

/* glfwWindowHint tokens */
pub const RED_BITS                     : c_int = 0x00021000;
pub const GREEN_BITS                   : c_int = 0x00021001;
pub const BLUE_BITS                    : c_int = 0x00021002;
pub const ALPHA_BITS                   : c_int = 0x00021003;
pub const DEPTH_BITS                   : c_int = 0x00021004;
pub const STENCIL_BITS                 : c_int = 0x00021005;
pub const ACCUM_RED_BITS               : c_int = 0x00021006;
pub const ACCUM_GREEN_BITS             : c_int = 0x00021007;
pub const ACCUM_BLUE_BITS              : c_int = 0x00021008;
pub const ACCUM_ALPHA_BITS             : c_int = 0x00021009;
pub const AUX_BUFFERS                  : c_int = 0x0002100A;
pub const STEREO                       : c_int = 0x0002100B;
pub const SAMPLES                      : c_int = 0x0002100C;
pub const SRGB_CAPABLE                 : c_int = 0x0002100D;

/* The following constants are used with both glfwGetWindowParam
 * and glfwWindowHint
 */
pub const CLIENT_API                   : c_int = 0x00022000;
pub const CONTEXT_VERSION_MAJOR        : c_int = 0x00022001;
pub const CONTEXT_VERSION_MINOR        : c_int = 0x00022002;
pub const CONTEXT_ROBUSTNESS           : c_int = 0x00022003;
pub const OPENGL_FORWARD_COMPAT        : c_int = 0x00022004;
pub const OPENGL_DEBUG_CONTEXT         : c_int = 0x00022005;
pub const OPENGL_PROFILE               : c_int = 0x00022006;
pub const RESIZABLE                    : c_int = 0x00022007;
pub const VISIBLE                      : c_int = 0x00022008;

/* GLFW_CLIENT_API tokens */
pub const OPENGL_API                   : c_int = 0x00000001;
pub const OPENGL_ES_API                : c_int = 0x00000002;

/* GLFW_CONTEXT_ROBUSTNESS mode tokens */
pub const NO_ROBUSTNESS                : c_int = 0x00000000;
pub const NO_RESET_NOTIFICATION        : c_int = 0x00000001;
pub const LOSE_CONTEXT_ON_RESET        : c_int = 0x00000002;

/* GLFW_OPENGL_PROFILE bit tokens */
pub const OPENGL_NO_PROFILE            : c_int = 0x00000000;
pub const OPENGL_CORE_PROFILE          : c_int = 0x00000001;
pub const OPENGL_COMPAT_PROFILE        : c_int = 0x00000002;

/* glfwGetInputMode/glfwSetInputMode tokens */
pub const CURSOR_MODE                  : c_int = 0x00030001;
pub const STICKY_KEYS                  : c_int = 0x00030002;
pub const STICKY_MOUSE_BUTTONS         : c_int = 0x00030003;

/* GLFW_CURSOR_MODE values */
pub const CURSOR_NORMAL                : c_int = 0x00040001;
pub const CURSOR_HIDDEN                : c_int = 0x00040002;
pub const CURSOR_CAPTURED              : c_int = 0x00040003;

/* glfwGetJoystickParam tokens */
pub const PRESENT                      : c_int = 0x00050001;
pub const AXES                         : c_int = 0x00050002;
pub const BUTTONS                      : c_int = 0x00050003;

/* glfwGetError/glfwErrorString tokens */
pub const NO_ERROR                     : c_int = 0;
pub const NOT_INITIALIZED              : c_int = 0x00070001;
pub const NO_CURRENT_CONTEXT           : c_int = 0x00070002;
pub const INVALID_ENUM                 : c_int = 0x00070003;
pub const INVALID_VALUE                : c_int = 0x00070004;
pub const OUT_OF_MEMORY                : c_int = 0x00070005;
pub const API_UNAVAILABLE              : c_int = 0x00070006;
pub const VERSION_UNAVAILABLE          : c_int = 0x00070007;
pub const PLATFORM_ERROR               : c_int = 0x00070008;
pub const FORMAT_UNAVAILABLE           : c_int = 0x00070009;

/* Gamma ramps */
pub const GAMMA_RAMP_SIZE              : c_int = 256;

/* Monitor event tokens */
pub const CONNECTED                    : c_int = 0x00061000;
pub const DISCONNECTED                 : c_int = 0x00061001;

/*************************************************************************
 * Typedefs
 *************************************************************************/

// /* OpenGL function pointer type */
// Will have to be changed once we can do external C callbacks nicely
pub type GLProc = *u8;              // typedef void (*GLFWglproc)(void);

// Wraps * pointer in a struct for safety
pub struct Monitor {
    ptr: *api::GLFWmonitor
}

// Wraps * pointer in a struct for safety
pub struct Window {
    ptr: *api::GLFWwindow
}

/* Function pointer types */
pub type ErrorFun           = @fn(error: c_int, format: ~str);
pub type WindowPosFun       = @fn(window: &Window, width: int, height: int);
pub type WindowSizeFun      = @fn(window: &Window, width: int, height: int);
pub type WindowCloseFun     = @fn(window: &Window) -> bool;
pub type WindowRefreshFun   = @fn(window: &Window);
pub type WindowFocusFun     = @fn(window: &Window, activated: bool);
pub type WindowIconifyFun   = @fn(window: &Window, iconified: bool);
pub type MouseButtonFun     = @fn(window: &Window, button: c_int, action: c_int);
pub type CursorPosFun       = @fn(window: &Window, x: int, y: int);
pub type CursorEnterFun     = @fn(window: &Window, entered: bool);
pub type ScrollFun          = @fn(window: &Window, x: f64, y: f64);
pub type KeyFun             = @fn(window: &Window, key: c_int, action: c_int);
pub type CharFun            = @fn(window: &Window, character: char);
pub type MonitorFun         = @fn(monitor: &Monitor, event: c_int);

/* The video mode structure used by glfwGetVideoModes */
pub struct VidMode {
    width      : c_int,
    height     : c_int,
    redBits    : c_int,
    blueBits   : c_int,
    greenBits  : c_int,
}

/* Gamma ramp */
// See https://github.com/mozilla/rust/issues/3469
pub struct GammaRamp {
    red     : [c_ushort * 256],      // unsigned short red[GLFW_GAMMA_RAMP_SIZE];
    green   : [c_ushort * 256],      // unsigned short green[GLFW_GAMMA_RAMP_SIZE];
    blue    : [c_ushort * 256],      // unsigned short blue[GLFW_GAMMA_RAMP_SIZE];
}

#[nolink]
pub mod api {
    use core::libc::*;

    /* Function pointer types */
    // Will have to be changed once we can do external C callbacks nicely
    pub type GLFWerrorfun           = *u8;  // typedef void (* GLFWerrorfun)(int,const char*);
    pub type GLFWwindowposfun       = *u8;  // typedef void (* GLFWwindowposfun)(*GLFWwindow,int,int);
    pub type GLFWwindowsizefun      = *u8;  // typedef void (* GLFWwindowsizefun)(*GLFWwindow,int,int);
    pub type GLFWwindowclosefun     = *u8;  // typedef int  (* GLFWwindowclosefun)(*GLFWwindow);
    pub type GLFWwindowrefreshfun   = *u8;  // typedef void (* GLFWwindowrefreshfun)(*GLFWwindow);
    pub type GLFWwindowfocusfun     = *u8;  // typedef void (* GLFWwindowfocusfun)(*GLFWwindow,int);
    pub type GLFWwindowiconifyfun   = *u8;  // typedef void (* GLFWwindowiconifyfun)(*GLFWwindow,int);
    pub type GLFWmousebuttonfun     = *u8;  // typedef void (* GLFWmousebuttonfun)(*GLFWwindow,int,int);
    pub type GLFWcursorposfun       = *u8;  // typedef void (* GLFWcursorposfun)(*GLFWwindow,int,int);
    pub type GLFWcursorenterfun     = *u8;  // typedef void (* GLFWcursorenterfun)(*GLFWwindow,int);
    pub type GLFWscrollfun          = *u8;  // typedef void (* GLFWscrollfun)(*GLFWwindow,double,double);
    pub type GLFWkeyfun             = *u8;  // typedef void (* GLFWkeyfun)(*GLFWwindow,int,int);
    pub type GLFWcharfun            = *u8;  // typedef void (* GLFWcharfun)(*GLFWwindow,int);
    pub type GLFWmonitorfun         = *u8;  // typedef void (* GLFWmonitorfun)(*GLFWmonitor,int);

    /* Monitor handle type */
    pub struct GLFWmonitor {}

    /* Window handle type */
    pub struct GLFWwindow {}

    pub type GLFWgammaramp = ::GammaRamp;
    pub type GLFWvidmode = ::VidMode;
    pub type GLFWglproc = ::GLProc;

    pub extern "C" {
        /* GLFW initialization, termination and version querying */
        pub fn glfwInit() -> c_int;
        pub fn glfwTerminate();
        pub fn glfwGetVersion(++major: *c_int, ++minor: *c_int, ++rev: *c_int);
        pub fn glfwGetVersionString() -> *c_char;

        /* Error handling */
        pub fn glfwSetErrorCallback(++cbfun: GLFWerrorfun);

        /* Monitor functions */
        pub fn glfwGetMonitors(++count: *c_int) -> **GLFWmonitor;
        pub fn glfwGetPrimaryMonitor() -> *GLFWmonitor;
        pub fn glfwGetMonitorPos(++monitor: *GLFWmonitor, ++xpos: *c_int, ++ypos: *c_int);
        pub fn glfwGetMonitorPhysicalSize(++monitor: *GLFWmonitor, ++width: *c_int, ++height: *c_int);
        pub fn glfwGetMonitorName(++monitor: *GLFWmonitor) -> *c_char;
        pub fn glfwSetMonitorCallback(++cbfun: GLFWmonitorfun);
        pub fn glfwGetVideoModes(++monitor: *GLFWmonitor, ++count: *c_int) -> *GLFWvidmode;
        pub fn glfwGetVideoMode(++monitor: *GLFWmonitor) -> GLFWvidmode;
        pub fn glfwSetGamma(++monitor: *GLFWmonitor, ++gamma: c_float);
        pub fn glfwGetGammaRamp(++monitor: *GLFWmonitor, ++ramp: *GLFWgammaramp);
        pub fn glfwSetGammaRamp(++monitor: *GLFWmonitor, ++ramp: *GLFWgammaramp);

        /* Window handling */
        pub fn glfwDefaultWindowHints();
        pub fn glfwWindowHint(++target: c_int, ++hint: c_int);
        pub fn glfwCreateWindow(++width: c_int, ++height: c_int, ++title: *c_char, ++monitor: *GLFWmonitor, ++share: *GLFWwindow) -> *GLFWwindow;
        pub fn glfwDestroyWindow(++window: *GLFWwindow);
        pub fn glfwSetWindowTitle(++window: *GLFWwindow, ++title: *c_char);
        pub fn glfwGetWindowPos(++window: *GLFWwindow, xpos: *c_int, ypos: *c_int);
        pub fn glfwSetWindowPos(++window: *GLFWwindow, xpos: c_int, ypos: c_int);
        pub fn glfwGetWindowSize(++window: *GLFWwindow, ++width: *c_int, ++height: *c_int);
        pub fn glfwSetWindowSize(++window: *GLFWwindow, ++width: c_int, ++height: c_int);
        pub fn glfwIconifyWindow(++window: *GLFWwindow);
        pub fn glfwRestoreWindow(++window: *GLFWwindow);
        pub fn glfwShowWindow(++window: *GLFWwindow);
        pub fn glfwHideWindow(++window: *GLFWwindow);
        pub fn glfwGetWindowMonitor(++window: *GLFWwindow) -> *GLFWmonitor;
        pub fn glfwGetWindowParam(++window: *GLFWwindow, ++param: c_int) -> c_int;
        pub fn glfwSetWindowUserPointer(++window: *GLFWwindow, ++pointer: *c_void);
        pub fn glfwGetWindowUserPointer(++window: *GLFWwindow) -> *c_void;
        pub fn glfwSetWindowPosCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowposfun);
        pub fn glfwSetWindowSizeCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowsizefun);
        pub fn glfwSetWindowCloseCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowclosefun);
        pub fn glfwSetWindowRefreshCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowrefreshfun);
        pub fn glfwSetWindowFocusCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowfocusfun);
        pub fn glfwSetWindowIconifyCallback(++window: *GLFWwindow, ++cbfun: GLFWwindowiconifyfun);

        /* Event handling */
        pub fn glfwPollEvents();
        pub fn glfwWaitEvents();

        /* Input handling */
        pub fn glfwGetInputMode(++window: *GLFWwindow, ++mode: c_int) -> c_int;
        pub fn glfwSetInputMode(++window: *GLFWwindow, ++mode: c_int, ++value: c_int);
        pub fn glfwGetKey(++window: *GLFWwindow, ++key: c_int) -> c_int;
        pub fn glfwGetMouseButton(++window: *GLFWwindow, ++button: c_int) -> c_int;
        pub fn glfwGetCursorPos(++window: *GLFWwindow, ++xpos: *c_int, ++ypos: *c_int);
        pub fn glfwSetCursorPos(++window: *GLFWwindow, ++xpos: c_int, ++ypos: c_int);
        pub fn glfwSetKeyCallback(++window: *GLFWwindow, ++cbfun: GLFWkeyfun);
        pub fn glfwSetCharCallback(++window: *GLFWwindow, ++cbfun: GLFWcharfun);
        pub fn glfwSetMouseButtonCallback(++window: *GLFWwindow, ++cbfun: GLFWmousebuttonfun);
        pub fn glfwSetCursorPosCallback(++window: *GLFWwindow, ++cbfun: GLFWcursorposfun);
        pub fn glfwSetCursorEnterCallback(++window: *GLFWwindow, ++cbfun: GLFWcursorenterfun);
        pub fn glfwSetScrollCallback(++window: *GLFWwindow, ++cbfun: GLFWscrollfun);

        /* Joystick input */
        pub fn glfwGetJoystickParam(++joy: c_int, ++param: c_int) -> c_int;
        pub fn glfwGetJoystickAxes(++joy: c_int, ++axes: *c_float, ++numaxes: c_int) -> c_int;
        pub fn glfwGetJoystickButtons(++joy: c_int, ++buttons: *c_uchar, ++numbuttons: c_int) -> c_int;
        pub fn glfwGetJoystickName(++joy: c_int) -> *c_char;

        /* Clipboard */
        pub fn glfwSetClipboardString(++window: *GLFWwindow, string: *c_char);
        pub fn glfwGetClipboardString(++window: *GLFWwindow) -> *c_char;

        /* Time */
        pub fn glfwGetTime() -> c_double;
        pub fn glfwSetTime(++time: c_double);

        /* OpenGL support */
        pub fn glfwMakeContextCurrent(++window: *GLFWwindow);
        pub fn glfwGetCurrentContext() -> *GLFWwindow;
        pub fn glfwSwapBuffers(++window: *GLFWwindow);
        pub fn glfwSwapInterval(++interval: c_int);
        pub fn glfwExtensionSupported(++extension: *c_char) -> c_int;
        pub fn glfwGetProcAddress(++procname: *c_char) -> GLFWglproc;
    }
}


/* GLFW initialization, termination and version querying */

pub fn init() -> bool {
    unsafe { api::glfwInit() as bool }
}

pub fn terminate() {
    unsafe { api::glfwTerminate(); }
}

/**
 * Initialises a glfw on the main platform thread. `glfw::terminate` is
 * automatically called on the success or failure of `f`
 */
pub fn spawn(f: ~fn()) {
    do task::task().sched_mode(task::PlatformThread).spawn {
        use core::private::finally::Finally;

        do (|| {
            if init() {
                f();        // do user-defined work
            } else {
                fail!(~"Failed to initialize GLFW");
            }
        }).finally {
            terminate();    // terminate glfw on completion or failure
        }
    }
}

pub struct Version {
    major: int,
    minor: int,
    rev:   int,
}

pub fn get_version() -> Version {
    let mut major = 0, minor = 0, rev = 0;

    unsafe {
        api::glfwGetVersion(
            to_unsafe_ptr(&major),
            to_unsafe_ptr(&minor),
            to_unsafe_ptr(&rev)
        );
    }

    Version {
        major: major as int,
        minor: minor as int,
        rev:   rev   as int,
    }
}

pub fn get_version_string() -> ~str {
    unsafe { str::raw::from_c_str(api::glfwGetVersionString()) }
}

/* Error handling */

fn errorfun_key(_f: @ErrorFun) {}

pub fn set_error_callback(cbfun: ErrorFun) {
    unsafe {
        local_data_set(errorfun_key, @cbfun);
        api::glfwSetErrorCallback(error_callback);
    }
}

extern fn error_callback(err: c_int, format: *c_char) {
    unsafe {
        match local_data_get(errorfun_key) {
            Some(f) => { (*f)(err, str::raw::from_c_str(format)); }
            None => {}
        }
    }
}


/* Monitor functions */

pub fn get_monitors() -> ~[Monitor] {
    unsafe {
        let mut count = 0;
        let ptr = api::glfwGetMonitors(to_unsafe_ptr(&count));

        do vec::from_buf(ptr, count as uint).map |&p| {
            Monitor::from_ptr(p)
        }
    }
}

pub fn get_primary_monitor() -> Monitor {
    unsafe { Monitor::from_ptr(api::glfwGetPrimaryMonitor()) }
}

pub impl Monitor {
    static fn from_ptr(ptr: *api::GLFWmonitor) -> Monitor {
        Monitor { ptr: ptr }
    }

    fn is_null(&self) -> bool {
        if self.ptr == ptr::null() { true } else { false }
    }

    fn get_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe {
            api::glfwGetMonitorPos(
                self.ptr,
                to_unsafe_ptr(&xpos),
                to_unsafe_ptr(&ypos)
            );
        }
        (xpos as int, ypos as int)
    }

    fn get_physical_size(&self) -> (int, int) {
        let mut width = 0, height = 0;
        unsafe {
            api::glfwGetMonitorPhysicalSize(
                self.ptr,
                to_unsafe_ptr(&width),
                to_unsafe_ptr(&height)
            );
        }
        (width as int, height as int)
    }

    fn get_name(&self) -> ~str {
        unsafe { str::raw::from_c_str(api::glfwGetMonitorName(self.ptr)) }
    }

    fn get_video_modes(&self) -> ~[VidMode] {
        unsafe {
            let mut count = 0;
            let ptr = api::glfwGetVideoModes(self.ptr, to_unsafe_ptr(&count));

            vec::from_buf(ptr, count as uint)
        }
    }

    fn get_video_mode(&self) -> VidMode {
        unsafe { api::glfwGetVideoMode(self.ptr) }
    }

    /* Gamma ramp functions */

    pub fn set_gamma(&self, gamma: float) {
        unsafe { api::glfwSetGamma(self.ptr, gamma as c_float); }
    }

    pub fn get_gamma_ramp(&self) -> GammaRamp {
        let mut ramp = GammaRamp {
            red:   [0, ..256],
            green: [0, ..256],
            blue:  [0, ..256],
        };

        unsafe { api::glfwGetGammaRamp(self.ptr, to_unsafe_ptr(&ramp)); }

        return ramp;
    }

    pub fn set_gamma_ramp(&self, ramp: &GammaRamp) {
        unsafe { api::glfwSetGammaRamp(self.ptr, to_unsafe_ptr(ramp)) }
    }
}

fn monitorfun_key(_f: @MonitorFun) {}

fn set_monitor_callback(cbfun: MonitorFun) {
    unsafe {
        local_data_set(monitorfun_key, @cbfun);
        api::glfwSetMonitorCallback(monitor_callback);
    }
}

extern fn monitor_callback(monitor: *api::GLFWmonitor, event: c_int) {
    unsafe {
        match local_data_get(monitorfun_key) {
            Some(f) => { (*f)(&Monitor::from_ptr(monitor), event); }
            None => {}
        }
    }
}

pub impl ToStr for VidMode {
    pure fn to_str(&self) -> ~str {
        fmt!("%? x %? %? (%? %? %?)",
             self.width, self.height,
             (self.redBits + self.blueBits + self.greenBits),
             self.redBits, self.blueBits, self.greenBits)
    }
}

/* Window handling */

pub fn default_window_hints() {
    unsafe { api::glfwDefaultWindowHints(); }
}

pub fn window_hint(target: c_int, hint: c_int) {
    unsafe { api::glfwWindowHint(target, hint); }
}

pub enum WindowMode {
    FullScreen(Monitor),
    Windowed,
}

pub impl Window {
    static fn from_ptr(ptr: *api::GLFWwindow) -> Window {
        Window { ptr: ptr }
    }

    static fn create(width: uint, height: uint, title: &str, mode: WindowMode) -> Option<Window> {
        Window::create_shared(width, height, title, mode, Window::from_ptr(ptr::null()))
    }

    static fn create_shared(width: uint, height: uint, title: &str, mode: WindowMode, share: Window) -> Option<Window> {
        let ptr = unsafe {
            api::glfwCreateWindow(
                width as c_int,
                height as c_int,
                unsafe { str::as_c_str(title, |a| a) },
                match mode {
                    FullScreen(m) => m.ptr,
                    Windowed => ptr::null()
                },
                share.ptr
            )
        };

        if !ptr.is_null() {
            Some(Window::from_ptr(ptr))
        } else {
            None
        }
    }

    fn is_null(&self) -> bool {
        if self.ptr == ptr::null() { true } else { false }
    }

    fn destroy(&self) {
        unsafe { api::glfwDestroyWindow(self.ptr); }
    }

    fn set_title(&self, title: &str) {
        unsafe { api::glfwSetWindowTitle(self.ptr, str::as_c_str(title, |a| a)) }
    }

    fn get_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe {
            api::glfwGetWindowPos(
                self.ptr,
                to_unsafe_ptr(&xpos),
                to_unsafe_ptr(&ypos)
            );
        }
        (xpos as int, ypos as int)
    }

    fn set_pos(&self, xpos: int, ypos: int) {
        unsafe { api::glfwSetWindowPos(self.ptr, xpos as c_int, ypos as c_int); }
    }

    fn get_size(&self) -> (int, int) {
        let mut width = 0, height = 0;
        unsafe {
            api::glfwGetWindowSize(
                self.ptr,
                to_unsafe_ptr(&width),
                to_unsafe_ptr(&height)
            );
        }
        (width as int, height as int)
    }

    fn set_size(&self, width: int, height: int) {
        unsafe { api::glfwSetWindowSize(self.ptr, width as c_int, height as c_int); }
    }

    fn iconify(&self) {
        unsafe { api::glfwIconifyWindow(self.ptr); }
    }

    fn restore(&self) {
        unsafe { api::glfwRestoreWindow(self.ptr); }
    }

    fn show(&self) {
        unsafe { api::glfwShowWindow(self.ptr); }
    }

    fn hide(&self) {
        unsafe { api::glfwHideWindow(self.ptr); }
    }

    fn get_monitor(&self) -> WindowMode {
        let m = unsafe { Monitor::from_ptr(api::glfwGetWindowMonitor(self.ptr)) };

        if m.is_null() { Windowed }
        else { FullScreen(m) }
    }

    fn get_param(&self, param: c_int) -> c_int {
        unsafe { api::glfwGetWindowParam(self.ptr, param) }
    }

    fn set_user_pointer(&self, pointer: *c_void) {
        unsafe { api::glfwSetWindowUserPointer(self.ptr, pointer); }
    }

    fn get_user_pointer(&self) -> *c_void {
        unsafe { api::glfwGetWindowUserPointer(self.ptr) }
    }

    fn set_pos_callback(&self, cbfun: WindowSizeFun) {
        unsafe {
            local_data_set(windowposfun_key, @cbfun);
            api::glfwSetWindowPosCallback(self.ptr, window_pos_callback);
        }
    }

    fn set_size_callback(&self, cbfun: WindowSizeFun) {
        unsafe {
            local_data_set(windowsizefun_key, @cbfun);
            api::glfwSetWindowSizeCallback(self.ptr, window_size_callback);
        }
    }

    fn set_close_callback(&self, cbfun: WindowCloseFun) {
        unsafe {
            local_data_set(windowclosefun_key, @cbfun);
            api::glfwSetWindowCloseCallback(self.ptr, window_close_callback);
        }
    }

    fn set_refresh_callback(&self, cbfun: WindowRefreshFun) {
        unsafe {
            local_data_set(windowrefreshfun_key, @cbfun);
            api::glfwSetWindowRefreshCallback(self.ptr, window_refresh_callback);
        }
    }

    fn set_focus_callback(&self, cbfun: WindowFocusFun) {
        unsafe {
            local_data_set(windowfocusfun_key, @cbfun);
            api::glfwSetWindowFocusCallback(self.ptr, window_focus_callback);
        }
    }

    fn set_iconify_callback(&self, cbfun: WindowIconifyFun) {
        unsafe {
            local_data_set(windowiconifyfun_key, @cbfun);
            api::glfwSetWindowIconifyCallback(self.ptr, window_iconify_callback);
        }
    }


    /* Input handling */

    fn get_input_mode(&self, mode: c_int) -> int {
        unsafe { api::glfwGetInputMode(self.ptr, mode) as int }
    }

    fn set_input_mode(&self, mode: c_int, value: int) {
        unsafe { api::glfwSetInputMode(self.ptr, mode, value as c_int); }
    }

    fn get_key(&self, key: c_int) -> c_int {
        unsafe { api::glfwGetKey(self.ptr, key) }
    }

    fn get_mouse_button(&self, button: c_int) -> c_int {
        unsafe { api::glfwGetMouseButton(self.ptr, button) }
    }

    fn get_cursor_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe {
            api::glfwGetCursorPos(
                self.ptr,
                to_unsafe_ptr(&xpos),
                to_unsafe_ptr(&ypos)
            );
        }

        return (xpos as int, ypos as int);
    }

    fn set_cursor_pos(&self, xpos: int, ypos: int) {
        unsafe { api::glfwSetCursorPos(self.ptr, xpos as c_int, ypos as c_int); }
    }

    fn set_key_callback(&self, cbfun: KeyFun) {
        unsafe {
            local_data_set(keyfun_key, @cbfun);
            api::glfwSetKeyCallback(self.ptr, key_callback);
        }
    }

    fn set_char_callback(&self, cbfun: CharFun) {
        unsafe {
            local_data_set(charfun_key, @cbfun);
            api::glfwSetCharCallback(self.ptr, char_callback);
        }
    }

    fn set_mouse_button_callback(&self, cbfun: MouseButtonFun) {
        unsafe {
            local_data_set(mousebuttonfun_key, @cbfun);
            api::glfwSetMouseButtonCallback(self.ptr, mouse_button_callback);
        }
    }

    fn set_cursor_pos_callback(&self, cbfun: CursorPosFun) {
        unsafe {
            local_data_set(cursorposfun_key, @cbfun);
            api::glfwSetCursorPosCallback(self.ptr, cursor_pos_callback);
        }
    }

    fn set_cursor_enter_callback(&self, cbfun: CursorEnterFun) {
        unsafe {
            local_data_set(cursorenterfun_key, @cbfun);
            api::glfwSetCursorEnterCallback(self.ptr, cursor_enter_callback);
        }
    }

    fn set_scroll_callback(&self, cbfun: ScrollFun) {
        unsafe {
            local_data_set(scrollfun_key, @cbfun);
            api::glfwSetScrollCallback(self.ptr, scroll_callback);
        }
    }

    /* Clipboard */

    fn set_clipboard_string(&self, string: &str) {
        unsafe { api::glfwSetClipboardString(self.ptr, str::as_c_str(string, |a| a)); }
    }

    fn get_clipboard_string(&self) -> ~str {
        unsafe { str::raw::from_c_str(api::glfwGetClipboardString(self.ptr)) }
    }

    /* OpenGL support */

    fn make_context_current(&self) {
        unsafe { api::glfwMakeContextCurrent(self.ptr); }
    }

    fn swap_buffers(&self) {
        unsafe { api::glfwSwapBuffers(self.ptr); }
    }
}

fn windowposfun_key(_f: @WindowPosFun) {}

extern fn window_pos_callback(window: *api::GLFWwindow, x: c_int, y: c_int) {
    unsafe {
        match local_data_get(windowposfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), x as int, y as int); }
            None => {}
        }
    }
}

fn windowsizefun_key(_f: @WindowSizeFun) {}

extern fn window_size_callback(window: *api::GLFWwindow, width: c_int, height: c_int) {
    unsafe {
        match local_data_get(windowsizefun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), width as int, height as int); }
            None => {}
        }
    }
}

fn windowclosefun_key(_f: @WindowCloseFun) {}

extern fn window_close_callback(window: *api::GLFWwindow) -> c_int {
    unsafe {
        match local_data_get(windowclosefun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window)) as c_int }
            None => { false as c_int }
        }
    }
}

// FIXME: Doesn't seem to work at the moment. See ../examples/callbacks.rs
fn windowrefreshfun_key(_f: @WindowRefreshFun) {}

extern fn window_refresh_callback(window: *api::GLFWwindow) {
    unsafe {
        match local_data_get(windowrefreshfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window)); }
            None => {}
        }
    }
}

fn windowfocusfun_key(_f: @WindowFocusFun) {}

extern fn window_focus_callback(window: *api::GLFWwindow, activated: c_int) {
    unsafe {
        match local_data_get(windowfocusfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), activated as bool); }
            None => {}
        }
    }
}

fn windowiconifyfun_key(_f: @WindowIconifyFun) {}

extern fn window_iconify_callback(window: *api::GLFWwindow, iconified: c_int) {
    unsafe {
        match local_data_get(windowiconifyfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), iconified as bool); }
            None => {}
        }
    }
}

/* Event handling */

pub fn poll_events() {
    unsafe { api::glfwPollEvents(); }
}

pub fn wait_events() {
    unsafe { api::glfwWaitEvents(); }
}

/* Input handling */

fn keyfun_key(_f: @KeyFun) {}

extern fn key_callback(window: *api::GLFWwindow, key: c_int, action: c_int) {
    unsafe {
        match local_data_get(keyfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), key, action); }
            None => {}
        }
    }
}

fn charfun_key(_f: @CharFun) {}

extern fn char_callback(window: *api::GLFWwindow, character: c_int) {
    unsafe {
        match local_data_get(charfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), character as char); }
            None => {}
        }
    }
}

fn mousebuttonfun_key(_f: @MouseButtonFun) {}

extern fn mouse_button_callback(window: *api::GLFWwindow, button: c_int, action: c_int) {
    unsafe {
        match local_data_get(mousebuttonfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), button, action); }
            None => {}
        }
    }
}

fn cursorposfun_key(_f: @CursorPosFun) {}

extern fn cursor_pos_callback(window: *api::GLFWwindow, x: c_int, y: c_int) {
    unsafe {
        match local_data_get(cursorposfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), x as int, y as int); }
            None => {}
        }
    }
}

fn cursorenterfun_key(_f: @CursorEnterFun) {}

extern fn cursor_enter_callback(window: *api::GLFWwindow, entered: c_int) {
    unsafe {
        match local_data_get(cursorenterfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), entered as bool); }
            None => {}
        }
    }
}

// FIXME: Doesn't seem to work at the moment. See ../examples/callbacks.rs
fn scrollfun_key(_f: @ScrollFun) {}

extern fn scroll_callback(window: *api::GLFWwindow, x: c_double, y: c_double) {
    unsafe {
        match local_data_get(scrollfun_key) {
            Some(f) => { (*f)(&Window::from_ptr(window), x as f64, y as f64); }
            None => {}
        }
    }
}
/*
// FIXME: https://github.com/bjz/glfw3-rs/issues/4
pub fn get_joysticks() -> ~[Joystick] {
    do Joysticks.filter_map |&joy| {
        if joy.is_present() { Some(joy) } else { None }
    }
}*/

/* Joystick input */
pub impl Joystick {
    fn get_param(&self, param: c_int) -> c_int {
        unsafe { api::glfwGetJoystickParam(self.id, param) }
    }

    fn is_present(&self) -> bool {
        self.get_param(PRESENT) as bool
    }

    fn num_axes(&self) -> Option<uint> {
        let axes = self.get_param(AXES);
        if axes > 0 { Some(axes as uint) } else { None }
    }

    fn num_buttons(&self) -> Option<uint> {
        let buttons = self.get_param(BUTTONS);
        if buttons > 0 { Some(buttons as uint) } else { None }
    }

    fn get_name(&self) -> ~str {
        unsafe { str::raw::from_c_str(api::glfwGetJoystickName(self.id)) }
    }

    /*
    	Example usage:
            let joy_axes = @mut [ 0.0f32, .. 2 ];
            let joy_axes = glfw::JOYSTICK_1.get_axes(joy_axes);
    */
    fn get_axes(&self, axes: &a/mut[f32]) -> &a/[const f32] {
        vec::const_slice(axes, 0u, unsafe { api::glfwGetJoystickAxes }(
        	self.id,
        	unsafe { transmute( vec::raw::to_mut_ptr(axes) ) },
        	axes.len() as c_int
        ) as uint )
    }

    /* See get_axes for usage instructions */
    fn get_buttons(&self, buttons: &a/mut[i8]) -> &a/[const i8] {
        vec::const_slice(buttons, 0u, unsafe { api::glfwGetJoystickButtons }(
        	self.id,
        	unsafe { transmute( vec::raw::to_mut_ptr(buttons) ) },
        	buttons.len() as c_int
        ) as uint )
    }
}

/* Time */

pub fn get_time() -> f64 {
    unsafe { api::glfwGetTime() as f64 }
}

pub fn set_time(time: f64) {
    unsafe { api::glfwSetTime(time as c_double); }
}

/* OpenGL support */

pub fn get_current_context() -> Window {
    Window { ptr: unsafe { api::glfwGetCurrentContext() } }
}

pub fn set_swap_interval(interval: int) {
    unsafe { api::glfwSwapInterval(interval as c_int); }
}

pub fn extension_supported(extension: &str) -> int {
    unsafe { api::glfwExtensionSupported(str::as_c_str(extension, |a| a)) as int }
}

pub fn get_proc_address(procname: &str) -> GLProc {
    unsafe { api::glfwGetProcAddress(str::as_c_str(procname, |a| a)) }
}
