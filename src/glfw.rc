#[link(name = "glfw",
	   vers = "0.1",
       uuid = "6199FAD3-6D03-4E29-87E7-7DC1B1B65C2C",
	   author = "Brendan Zabarauskas",
	   url = "https://github.com/bjz/glfw3-rs")];

#[comment = "Bindings and wrapper functions for glfw3."];
#[crate_type = "lib"];

use core::libc::*;

mod event;
mod ll;

/*************************************************************************
 * GLFW version
 *************************************************************************/

pub static VERSION_MAJOR        : c_int = 3;
pub static VERSION_MINOR        : c_int = 0;
pub static VERSION_REVISION     : c_int = 0;

/*************************************************************************
 * Input handling definitions
 *************************************************************************/

/* Key and button state/action definitions */
pub static RELEASE              : c_int = 0;
pub static PRESS                : c_int = 1;
pub static REPEAT               : c_int = 2;

/* Printable keys */
pub static KEY_SPACE            : c_int = 32;
pub static KEY_APOSTROPHE       : c_int = 39;  /* ' */
pub static KEY_COMMA            : c_int = 44;  /* , */
pub static KEY_MINUS            : c_int = 45;  /* - */
pub static KEY_PERIOD           : c_int = 46;  /* . */
pub static KEY_SLASH            : c_int = 47;  /* / */
pub static KEY_0                : c_int = 48;
pub static KEY_1                : c_int = 49;
pub static KEY_2                : c_int = 50;
pub static KEY_3                : c_int = 51;
pub static KEY_4                : c_int = 52;
pub static KEY_5                : c_int = 53;
pub static KEY_6                : c_int = 54;
pub static KEY_7                : c_int = 55;
pub static KEY_8                : c_int = 56;
pub static KEY_9                : c_int = 57;
pub static KEY_SEMICOLON        : c_int = 59;  /* ; */
pub static KEY_EQUAL            : c_int = 61;  /* = */
pub static KEY_A                : c_int = 65;
pub static KEY_B                : c_int = 66;
pub static KEY_C                : c_int = 67;
pub static KEY_D                : c_int = 68;
pub static KEY_E                : c_int = 69;
pub static KEY_F                : c_int = 70;
pub static KEY_G                : c_int = 71;
pub static KEY_H                : c_int = 72;
pub static KEY_I                : c_int = 73;
pub static KEY_J                : c_int = 74;
pub static KEY_K                : c_int = 75;
pub static KEY_L                : c_int = 76;
pub static KEY_M                : c_int = 77;
pub static KEY_N                : c_int = 78;
pub static KEY_O                : c_int = 79;
pub static KEY_P                : c_int = 80;
pub static KEY_Q                : c_int = 81;
pub static KEY_R                : c_int = 82;
pub static KEY_S                : c_int = 83;
pub static KEY_T                : c_int = 84;
pub static KEY_U                : c_int = 85;
pub static KEY_V                : c_int = 86;
pub static KEY_W                : c_int = 87;
pub static KEY_X                : c_int = 88;
pub static KEY_Y                : c_int = 89;
pub static KEY_Z                : c_int = 90;
pub static KEY_LEFT_BRACKET     : c_int = 91;  /* [ */
pub static KEY_BACKSLASH        : c_int = 92;  /* \ */
pub static KEY_RIGHT_BRACKET    : c_int = 93;  /* ] */
pub static KEY_GRAVE_ACCENT     : c_int = 96;  /* ` */
pub static KEY_WORLD_1          : c_int = 161; /* non-US #1 */
pub static KEY_WORLD_2          : c_int = 162; /* non-US #2 */

/* Function keys */
pub static KEY_ESCAPE           : c_int = 256;
pub static KEY_ENTER            : c_int = 257;
pub static KEY_TAB              : c_int = 258;
pub static KEY_BACKSPACE        : c_int = 259;
pub static KEY_INSERT           : c_int = 260;
pub static KEY_DELETE           : c_int = 261;
pub static KEY_RIGHT            : c_int = 262;
pub static KEY_LEFT             : c_int = 263;
pub static KEY_DOWN             : c_int = 264;
pub static KEY_UP               : c_int = 265;
pub static KEY_PAGE_UP          : c_int = 266;
pub static KEY_PAGE_DOWN        : c_int = 267;
pub static KEY_HOME             : c_int = 268;
pub static KEY_END              : c_int = 269;
pub static KEY_CAPS_LOCK        : c_int = 280;
pub static KEY_SCROLL_LOCK      : c_int = 281;
pub static KEY_NUM_LOCK         : c_int = 282;
pub static KEY_PRINT_SCREEN     : c_int = 283;
pub static KEY_PAUSE            : c_int = 284;
pub static KEY_F1               : c_int = 290;
pub static KEY_F2               : c_int = 291;
pub static KEY_F3               : c_int = 292;
pub static KEY_F4               : c_int = 293;
pub static KEY_F5               : c_int = 294;
pub static KEY_F6               : c_int = 295;
pub static KEY_F7               : c_int = 296;
pub static KEY_F8               : c_int = 297;
pub static KEY_F9               : c_int = 298;
pub static KEY_F10              : c_int = 299;
pub static KEY_F11              : c_int = 300;
pub static KEY_F12              : c_int = 301;
pub static KEY_F13              : c_int = 302;
pub static KEY_F14              : c_int = 303;
pub static KEY_F15              : c_int = 304;
pub static KEY_F16              : c_int = 305;
pub static KEY_F17              : c_int = 306;
pub static KEY_F18              : c_int = 307;
pub static KEY_F19              : c_int = 308;
pub static KEY_F20              : c_int = 309;
pub static KEY_F21              : c_int = 310;
pub static KEY_F22              : c_int = 311;
pub static KEY_F23              : c_int = 312;
pub static KEY_F24              : c_int = 313;
pub static KEY_F25              : c_int = 314;
pub static KEY_KP_0             : c_int = 320;
pub static KEY_KP_1             : c_int = 321;
pub static KEY_KP_2             : c_int = 322;
pub static KEY_KP_3             : c_int = 323;
pub static KEY_KP_4             : c_int = 324;
pub static KEY_KP_5             : c_int = 325;
pub static KEY_KP_6             : c_int = 326;
pub static KEY_KP_7             : c_int = 327;
pub static KEY_KP_8             : c_int = 328;
pub static KEY_KP_9             : c_int = 329;
pub static KEY_KP_DECIMAL       : c_int = 330;
pub static KEY_KP_DIVIDE        : c_int = 331;
pub static KEY_KP_MULTIPLY      : c_int = 332;
pub static KEY_KP_SUBTRACT      : c_int = 333;
pub static KEY_KP_ADD           : c_int = 334;
pub static KEY_KP_ENTER         : c_int = 335;
pub static KEY_KP_EQUAL         : c_int = 336;
pub static KEY_LEFT_SHIFT       : c_int = 340;
pub static KEY_LEFT_CONTROL     : c_int = 341;
pub static KEY_LEFT_ALT         : c_int = 342;
pub static KEY_LEFT_SUPER       : c_int = 343;
pub static KEY_RIGHT_SHIFT      : c_int = 344;
pub static KEY_RIGHT_CONTROL    : c_int = 345;
pub static KEY_RIGHT_ALT        : c_int = 346;
pub static KEY_RIGHT_SUPER      : c_int = 347;
pub static KEY_MENU             : c_int = 348;
pub static KEY_LAST             : c_int = KEY_MENU;

/* Mouse buttons */
pub static MOUSE_BUTTON_1       : c_int = 0;
pub static MOUSE_BUTTON_2       : c_int = 1;
pub static MOUSE_BUTTON_3       : c_int = 2;
pub static MOUSE_BUTTON_4       : c_int = 3;
pub static MOUSE_BUTTON_5       : c_int = 4;
pub static MOUSE_BUTTON_6       : c_int = 5;
pub static MOUSE_BUTTON_7       : c_int = 6;
pub static MOUSE_BUTTON_8       : c_int = 7;
pub static MOUSE_BUTTON_LEFT    : c_int = MOUSE_BUTTON_1;
pub static MOUSE_BUTTON_RIGHT   : c_int = MOUSE_BUTTON_2;
pub static MOUSE_BUTTON_MIDDLE  : c_int = MOUSE_BUTTON_3;
pub static MOUSE_BUTTON_LAST    : c_int = MOUSE_BUTTON_8;

/* Joysticks */
pub static JOYSTICK_1           : c_int = 0;
pub static JOYSTICK_2           : c_int = 1;
pub static JOYSTICK_3           : c_int = 2;
pub static JOYSTICK_4           : c_int = 3;
pub static JOYSTICK_5           : c_int = 4;
pub static JOYSTICK_6           : c_int = 5;
pub static JOYSTICK_7           : c_int = 6;
pub static JOYSTICK_8           : c_int = 7;
pub static JOYSTICK_9           : c_int = 8;
pub static JOYSTICK_10          : c_int = 9;
pub static JOYSTICK_11          : c_int = 10;
pub static JOYSTICK_12          : c_int = 11;
pub static JOYSTICK_13          : c_int = 12;
pub static JOYSTICK_14          : c_int = 13;
pub static JOYSTICK_15          : c_int = 14;
pub static JOYSTICK_16          : c_int = 15;
pub static JOYSTICK_LAST        : c_int = JOYSTICK_16;

/*************************************************************************
 * Other definitions
 *************************************************************************/

/* Not actually defined in GLFW, but very useful */
pub static FALSE                        : c_int = 0;
pub static TRUE                         : c_int = 1;

/* glfwGetWindowParam tokens */
pub static FOCUSED                      : c_int = 0x00020001;
pub static ICONIFIED                    : c_int = 0x00020002;
pub static CONTEXT_REVISION             : c_int = 0x00020004;

/* glfwWindowHint tokens */
pub static RED_BITS                     : c_int = 0x00021000;
pub static GREEN_BITS                   : c_int = 0x00021001;
pub static BLUE_BITS                    : c_int = 0x00021002;
pub static ALPHA_BITS                   : c_int = 0x00021003;
pub static DEPTH_BITS                   : c_int = 0x00021004;
pub static STENCIL_BITS                 : c_int = 0x00021005;
pub static ACCUM_RED_BITS               : c_int = 0x00021006;
pub static ACCUM_GREEN_BITS             : c_int = 0x00021007;
pub static ACCUM_BLUE_BITS              : c_int = 0x00021008;
pub static ACCUM_ALPHA_BITS             : c_int = 0x00021009;
pub static AUX_BUFFERS                  : c_int = 0x0002100A;
pub static STEREO                       : c_int = 0x0002100B;
pub static SAMPLES                      : c_int = 0x0002100C;
pub static SRGB_CAPABLE                 : c_int = 0x0002100D;

/* The following constants are used with both glfwGetWindowParam
 * and glfwWindowHint
 */
pub static CLIENT_API                   : c_int = 0x00022000;
pub static CONTEXT_VERSION_MAJOR        : c_int = 0x00022001;
pub static CONTEXT_VERSION_MINOR        : c_int = 0x00022002;
pub static CONTEXT_ROBUSTNESS           : c_int = 0x00022003;
pub static OPENGL_FORWARD_COMPAT        : c_int = 0x00022004;
pub static OPENGL_DEBUG_CONTEXT         : c_int = 0x00022005;
pub static OPENGL_PROFILE               : c_int = 0x00022006;
pub static RESIZABLE                    : c_int = 0x00022007;
pub static VISIBLE                      : c_int = 0x00022008;

/* GLFW_CLIENT_API tokens */
pub static OPENGL_API                   : c_int = 0x00000001;
pub static OPENGL_ES_API                : c_int = 0x00000002;

/* GLFW_CONTEXT_ROBUSTNESS mode tokens */
pub static NO_ROBUSTNESS                : c_int = 0x00000000;
pub static NO_RESET_NOTIFICATION        : c_int = 0x00000001;
pub static LOSE_CONTEXT_ON_RESET        : c_int = 0x00000002;

/* GLFW_OPENGL_PROFILE bit tokens */
pub static OPENGL_NO_PROFILE            : c_int = 0x00000000;
pub static OPENGL_CORE_PROFILE          : c_int = 0x00000001;
pub static OPENGL_COMPAT_PROFILE        : c_int = 0x00000002;

/* glfwGetInputMode/glfwSetInputMode tokens */
pub static CURSOR_MODE                  : c_int = 0x00030001;
pub static STICKY_KEYS                  : c_int = 0x00030002;
pub static STICKY_MOUSE_BUTTONS         : c_int = 0x00030003;

/* GLFW_CURSOR_MODE values */
pub static CURSOR_NORMAL                : c_int = 0x00040001;
pub static CURSOR_HIDDEN                : c_int = 0x00040002;
pub static CURSOR_CAPTURED              : c_int = 0x00040003;

/* glfwGetJoystickParam tokens */
pub static PRESENT                      : c_int = 0x00050001;
pub static AXES                         : c_int = 0x00050002;
pub static BUTTONS                      : c_int = 0x00050003;

/* glfwGetError/glfwErrorString tokens */
pub static NOT_INITIALIZED              : c_int = 0x00070001;
pub static NO_CURRENT_CONTEXT           : c_int = 0x00070002;
pub static INVALID_ENUM                 : c_int = 0x00070003;
pub static INVALID_VALUE                : c_int = 0x00070004;
pub static OUT_OF_MEMORY                : c_int = 0x00070005;
pub static API_UNAVAILABLE              : c_int = 0x00070006;
pub static VERSION_UNAVAILABLE          : c_int = 0x00070007;
pub static PLATFORM_ERROR               : c_int = 0x00070008;
pub static FORMAT_UNAVAILABLE           : c_int = 0x00070009;

/* Gamma ramps */
pub static GAMMA_RAMP_SIZE              : c_int = 256;

/* Monitor event tokens */
pub static CONNECTED                    : c_int = 0x00061000;
pub static DISCONNECTED                 : c_int = 0x00061001;

/*************************************************************************
 * Typedefs
 *************************************************************************/

// /* OpenGL function pointer type */
// Will have to be changed once we can do external C callbacks nicely
pub type GLProc = *u8;              // typedef void (*GLFWglproc)(void);

pub struct Monitor(*ll::GLFWmonitor);

pub struct Window(*ll::GLFWwindow);

/* Function pointer types */
pub type ErrorFun           = @fn(error: c_int, format: ~str);
pub type WindowPosFun       = @fn(window: &Window, width: int, height: int);
pub type WindowSizeFun      = @fn(window: &Window, width: int, height: int);
pub type WindowCloseFun     = @fn(window: &Window);
pub type WindowRefreshFun   = @fn(window: &Window);
pub type WindowFocusFun     = @fn(window: &Window, activated: bool);
pub type WindowIconifyFun   = @fn(window: &Window, iconified: bool);
pub type MouseButtonFun     = @fn(window: &Window, button: c_int, action: c_int);
pub type CursorPosFun       = @fn(window: &Window, x: int, y: int);
pub type CursorEnterFun     = @fn(window: &Window, entered: bool);
pub type ScrollFun          = @fn(window: &Window, x: f64, y: f64);
pub type KeyFun             = @fn(window: &Window, key: c_int, action: c_int);
pub type CharFun            = @fn(window: &Window, character: char);
pub type MonitorFun         = @fn(monitor: &Monitor, event: c_int);

/* The video mode structure used by glfwGetVideoModes */
pub struct VidMode {
    width      : c_int,
    height     : c_int,
    redBits    : c_int,
    blueBits   : c_int,
    greenBits  : c_int,
}

/* Gamma ramp */
pub struct GammaRamp {
    red     : [c_ushort, ..GAMMA_RAMP_SIZE],
    green   : [c_ushort, ..GAMMA_RAMP_SIZE],
    blue    : [c_ushort, ..GAMMA_RAMP_SIZE],
}

/* GLFW initialization, termination and version querying */

/**
 * Manually initialise GLFW. Returns `false` if unsuccessful.
 */
pub fn init() -> bool {
    unsafe { ll::glfwInit() as bool }
}

/**
 * Manually terminate GLFW.
 */
pub fn terminate() {
    unsafe { ll::glfwTerminate(); }
}

/**
 * Initialises GLFW on the main platform thread. `glfw::terminate` is
 * automatically called on the success or failure of `f`
 */
pub fn spawn(f: ~fn()) {
    do task::spawn_sched(task::PlatformThread) {
        use core::unstable::finally::Finally;

        do (|| {
            if init() {
                f();        // do user-defined work
            } else {
                fail!(~"Failed to initialize GLFW");
            }
        }).finally {
            terminate();    // terminate glfw on completion or failure
        }
    }
}

/**
 * A struct containing the GLFW version numbers.
 */
pub struct Version {
    major: int,
    minor: int,
    rev:   int,
}

pub fn get_version() -> Version {
    let mut major = 0, minor = 0, rev = 0;

    unsafe { ll::glfwGetVersion(&major, &minor, &rev); }

    Version {
        major: major as int,
        minor: minor as int,
        rev:   rev   as int,
    }
}

pub fn get_version_string() -> ~str {
    unsafe { str::raw::from_c_str(ll::glfwGetVersionString()) }
}

/* Error handling */

pub fn set_error_callback(cbfun: ErrorFun) {
    do event::error::set_callback(cbfun) |ext_cb| {
        unsafe { ll::glfwSetErrorCallback(ext_cb); }
    }
}


/* Monitor functions */

pub fn get_monitors() -> ~[Monitor] {
    unsafe {
        let mut count = 0;
        let ptr = ll::glfwGetMonitors(&count);
        vec::from_buf(ptr, count as uint).map(|&p| Monitor(p))
    }
}

pub fn get_primary_monitor() -> Monitor {
    unsafe { Monitor(ll::glfwGetPrimaryMonitor()) }
}

pub impl Monitor {
    fn ptr(&self) -> *ll::GLFWmonitor { **self }
    
    fn is_null(&self) -> bool { self.ptr().is_null() }
    
    fn null() -> Monitor { Monitor(ptr::null()) }

    fn get_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe { ll::glfwGetMonitorPos(self.ptr(), &xpos, &ypos); }
        (xpos as int, ypos as int)
    }

    fn get_physical_size(&self) -> (int, int) {
        let mut width = 0, height = 0;
        unsafe { ll::glfwGetMonitorPhysicalSize(self.ptr(), &width, &height); }
        (width as int, height as int)
    }

    fn get_name(&self) -> ~str {
        unsafe { str::raw::from_c_str(ll::glfwGetMonitorName(self.ptr())) }
    }

    fn get_video_modes(&self) -> ~[VidMode] {
        unsafe {
            let mut count = 0;
            let ptr = ll::glfwGetVideoModes(self.ptr(), &count);
            vec::from_buf(ptr, count as uint)
        }
    }

    fn get_video_mode(&self) -> VidMode {
        unsafe { ll::glfwGetVideoMode(self.ptr()) }
    }

    /* Gamma ramp functions */

    pub fn set_gamma(&self, gamma: float) {
        unsafe { ll::glfwSetGamma(self.ptr(), gamma as c_float); }
    }

    pub fn get_gamma_ramp(&self) -> GammaRamp {
        let mut ramp = GammaRamp {
            red:   [0, ..GAMMA_RAMP_SIZE],
            green: [0, ..GAMMA_RAMP_SIZE],
            blue:  [0, ..GAMMA_RAMP_SIZE],
        };
        unsafe { ll::glfwGetGammaRamp(self.ptr(), &ramp); }
        return ramp;
    }

    pub fn set_gamma_ramp(&self, ramp: &GammaRamp) {
        unsafe { ll::glfwSetGammaRamp(self.ptr(), ramp); }
    }
}

fn set_monitor_callback(cbfun: MonitorFun) {
    do event::monitor::set_callback(cbfun) |ext_cb| {
        unsafe { ll::glfwSetMonitorCallback(ext_cb); }
    }
}

impl ToStr for VidMode {
    fn to_str(&self) -> ~str {
        fmt!("%? x %? %? (%? %? %?)",
             self.width, self.height,
             (self.redBits + self.blueBits + self.greenBits),
             self.redBits, self.blueBits, self.greenBits)
    }
}

/* Window handling */

pub fn default_window_hints() {
    unsafe { ll::glfwDefaultWindowHints(); }
}

pub fn window_hint(target: c_int, hint: c_int) {
    unsafe { ll::glfwWindowHint(target, hint); }
}

pub enum WindowMode {
    FullScreen(Monitor),
    Windowed,
}

pub impl Window {
    fn ptr(&self) -> *ll::GLFWwindow { **self }

    fn is_null(&self) -> bool { self.ptr().is_null() }
    
    fn null() -> Window { Window(ptr::null()) }

    fn create(width: uint, height: uint, title: &str, mode: WindowMode) -> Option<Window> {
        Window::create_shared(width, height, title, mode, &Window::null())
    }

    fn create_shared(width: uint, height: uint, title: &str, mode: WindowMode, share: &Window) -> Option<Window> {
        let window = Window(
            unsafe {
                ll::glfwCreateWindow(
                    width as c_int,
                    height as c_int,
                    unsafe { str::as_c_str(title, |a| a) },
                    match mode {
                        FullScreen(m) => m.ptr(),
                        Windowed => ptr::null()
                    },
                    share.ptr()
                )
            }
        );

        if !window.is_null() { Some(window) } else { None }
    }

    fn destroy(&self) {
        unsafe { ll::glfwDestroyWindow(self.ptr()); }
    }
    
    fn should_close(&self) -> bool {
        unsafe { ll::glfwWindowShouldClose(self.ptr()) as bool }
    }
    
    fn set_should_close(&self, value: bool) {
        unsafe { ll::glfwSetWindowShouldClose(self.ptr(), value as c_int) }
    }

    fn set_title(&self, title: &str) {
        unsafe { ll::glfwSetWindowTitle(self.ptr(), str::as_c_str(title, |a| a)) }
    }

    fn get_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe { ll::glfwGetWindowPos(self.ptr(), &xpos, &ypos); }
        (xpos as int, ypos as int)
    }

    fn set_pos(&self, xpos: int, ypos: int) {
        unsafe { ll::glfwSetWindowPos(self.ptr(), xpos as c_int, ypos as c_int); }
    }

    fn get_size(&self) -> (int, int) {
        let mut width = 0, height = 0;
        unsafe { ll::glfwGetWindowSize(self.ptr(), &width, &height); }
        (width as int, height as int)
    }

    fn set_size(&self, width: int, height: int) {
        unsafe { ll::glfwSetWindowSize(self.ptr(), width as c_int, height as c_int); }
    }

    fn iconify(&self) {
        unsafe { ll::glfwIconifyWindow(self.ptr()); }
    }

    fn restore(&self) {
        unsafe { ll::glfwRestoreWindow(self.ptr()); }
    }

    fn show(&self) {
        unsafe { ll::glfwShowWindow(self.ptr()); }
    }

    fn hide(&self) {
        unsafe { ll::glfwHideWindow(self.ptr()); }
    }

    fn get_monitor(&self) -> WindowMode {
        let m = unsafe { Monitor(ll::glfwGetWindowMonitor(self.ptr())) };

        if m.is_null() { Windowed }
        else { FullScreen(m) }
    }

    fn get_param(&self, param: c_int) -> c_int {
        unsafe { ll::glfwGetWindowParam(self.ptr(), param) }
    }

    fn set_user_pointer(&self, pointer: *c_void) {
        unsafe { ll::glfwSetWindowUserPointer(self.ptr(), pointer); }
    }

    fn get_user_pointer(&self) -> *c_void {
        unsafe { ll::glfwGetWindowUserPointer(self.ptr()) }
    }
    
    /* Window event callbacks */

    fn set_pos_callback(&self, cbfun: WindowSizeFun) {
        do event::windowpos::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowPosCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_size_callback(&self, cbfun: WindowSizeFun) {
        do event::windowsize::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowSizeCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_close_callback(&self, cbfun: WindowCloseFun) {
        do event::windowclose::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowCloseCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_refresh_callback(&self, cbfun: WindowRefreshFun) {
        do event::windowrefresh::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowRefreshCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_focus_callback(&self, cbfun: WindowFocusFun) {
        do event::windowfocus::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowFocusCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_iconify_callback(&self, cbfun: WindowIconifyFun) {
        do event::windowiconify::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetWindowIconifyCallback(self.ptr(), ext_cb); }
        }
    }

    
    /* Input handling */

    fn get_input_mode(&self, mode: c_int) -> int {
        unsafe { ll::glfwGetInputMode(self.ptr(), mode) as int }
    }

    fn set_input_mode(&self, mode: c_int, value: int) {
        unsafe { ll::glfwSetInputMode(self.ptr(), mode, value as c_int); }
    }

    fn get_key(&self, key: c_int) -> c_int {
        unsafe { ll::glfwGetKey(self.ptr(), key) }
    }

    fn get_mouse_button(&self, button: c_int) -> c_int {
        unsafe { ll::glfwGetMouseButton(self.ptr(), button) }
    }

    fn get_cursor_pos(&self) -> (int, int) {
        let mut xpos = 0, ypos = 0;
        unsafe { ll::glfwGetCursorPos(self.ptr(), &xpos, &ypos); }
        return (xpos as int, ypos as int);
    }

    fn set_cursor_pos(&self, xpos: int, ypos: int) {
        unsafe { ll::glfwSetCursorPos(self.ptr(), xpos as c_int, ypos as c_int); }
    }
    
    /* Input Callbacks */

    fn set_key_callback(&self, cbfun: KeyFun) {
        do event::key::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetKeyCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_char_callback(&self, cbfun: CharFun) {
        do event::char::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetCharCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_mouse_button_callback(&self, cbfun: MouseButtonFun) {
        do event::mousebutton::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetMouseButtonCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_cursor_pos_callback(&self, cbfun: CursorPosFun) {
        do event::cursorpos::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetCursorPosCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_cursor_enter_callback(&self, cbfun: CursorEnterFun) {
        do event::cursorenter::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetCursorEnterCallback(self.ptr(), ext_cb); }
        }
    }

    fn set_scroll_callback(&self, cbfun: ScrollFun) {
        do event::scroll::set_callback(cbfun) |ext_cb| {
            unsafe { ll::glfwSetScrollCallback(self.ptr(), ext_cb); }
        }
    }

    /* Clipboard */

    fn set_clipboard_string(&self, string: &str) {
        unsafe { ll::glfwSetClipboardString(self.ptr(), str::as_c_str(string, |a| a)); }
    }

    fn get_clipboard_string(&self) -> ~str {
        unsafe { str::raw::from_c_str(ll::glfwGetClipboardString(self.ptr())) }
    }

    /* OpenGL support */

    fn make_context_current(&self) {
        unsafe { ll::glfwMakeContextCurrent(self.ptr()); }
    }

    fn swap_buffers(&self) {
        unsafe { ll::glfwSwapBuffers(self.ptr()); }
    }
}

/* Event handling */

pub fn poll_events() {
    unsafe { ll::glfwPollEvents(); }
}

pub fn wait_events() {
    unsafe { ll::glfwWaitEvents(); }
}

/* Joystick input */
pub mod joystick {
    use core::libc::*;
    
    pub fn get_param(joy: c_int, param: c_int) -> c_int  {
        unsafe { ::ll::glfwGetJoystickParam(joy, param) }
    }
    
    pub fn is_present(joy: c_int) -> bool {
        get_param(joy, ::PRESENT) as bool
    }
    
    pub fn num_axes(joy: c_int) -> Option<uint> {
        let axes = get_param(joy, ::AXES);
        if axes > 0 { Some(axes as uint) } else { None }
    }
    
    pub fn num_buttons(joy: c_int) -> Option<uint> {
        let buttons = get_param(joy, ::BUTTONS);
        if buttons > 0 { Some(buttons as uint) } else { None }
    }

    pub fn get_name(joy: c_int) -> ~str {
        unsafe { str::raw::from_c_str(::ll::glfwGetJoystickName(joy)) }
    }

    pub fn get_axes(joy: c_int) -> Result<~[float],()> {
        do num_axes(joy).map_default(Err(())) |&num| {
            let mut axes = ~[];
            vec::grow(&mut axes, num, &0.0);
            
            if unsafe { ::ll::glfwGetJoystickAxes(joy, &axes[0], num as c_int) > 0 } {
                Ok(axes.map(|&a| a as float))
            } else {
                Err(())
            }
        }
    }

    pub fn get_buttons(joy: c_int) -> Result<~[int],()> {
        do num_axes(joy).map_default(Err(())) |&num| {
            let mut buttons = ~[];
            vec::grow(&mut buttons, num, &0);
            
            if unsafe { ::ll::glfwGetJoystickButtons(joy, &buttons[0], num as c_int) > 0 } {
                Ok(buttons.map(|&a| a as int))
            } else {
                Err(())
            }
        }
    }
}


/* Time */

pub fn get_time() -> f64 {
    unsafe { ll::glfwGetTime() as f64 }
}

pub fn set_time(time: f64) {
    unsafe { ll::glfwSetTime(time as c_double); }
}

/* OpenGL support */

pub fn get_current_context() -> Window {
    Window(unsafe { ll::glfwGetCurrentContext() })
}

pub fn set_swap_interval(interval: int) {
    unsafe { ll::glfwSwapInterval(interval as c_int); }
}

pub fn extension_supported(extension: &str) -> bool {
    unsafe { ll::glfwExtensionSupported(str::as_c_str(extension, |a| a)) as bool }
}

pub fn get_proc_address(procname: &str) -> GLProc {
    unsafe { ll::glfwGetProcAddress(str::as_c_str(procname, |a| a)) }
}
